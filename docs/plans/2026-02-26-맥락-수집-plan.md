# Linear/GitHub 맥락 수집 시스템 구현 계획

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Linear/GitHub 이벤트를 n8n 웹훅으로 자동 수집하여 PostgreSQL에 저장하고, MCP 도구로 조회할 수 있게 한다.

**Architecture:** Push 방식 — Linear/GitHub 웹훅 → n8n 수집 워크플로우 → Coolify PostgreSQL 저장 → n8n MCP 조회 워크플로우로 Markdown 요약 반환. 총 3개 독립 워크플로우.

**Tech Stack:** n8n (MCP 도구로 워크플로우 생성), PostgreSQL (Coolify), Linear 웹훅, GitHub 웹훅

**참조 스킬:**
- `n8n-gotchas` — 노드 설정 시 알려진 함정 회피
- `n8n-node-configuration` — 노드 파라미터 설정 가이드
- `n8n-mcp-tools-expert` — MCP 도구 사용법

---

## Task 0: PostgreSQL 인프라 구축

**목표:** Coolify에서 PostgreSQL 인스턴스를 생성하고, n8n에서 접근 가능한 credential을 설정한다.

**Step 1: Coolify에서 PostgreSQL 서비스 생성**

Coolify 대시보드에서 PostgreSQL 서비스를 추가한다. 사용자가 직접 Coolify UI에서 수행.

필요한 정보:
- DB 이름: `context_db`
- 사용자: `context_user`
- 비밀번호: (사용자가 설정)
- 포트: 5432

**Step 2: n8n에서 PostgreSQL credential 생성**

n8n MCP 도구를 사용하여 credential을 생성한다. 또는 n8n UI에서 직접 생성.

접속 정보:
- Host: `host.docker.internal` (Coolify Docker 환경, `n8n-gotchas` 참조)
- Port: PostgreSQL 서비스의 외부 매핑 포트
- Database: `context_db`
- User: `context_user`
- Password: (설정한 비밀번호)

**Step 3: 연결 테스트**

n8n에서 간단한 워크플로우를 만들어 PostgreSQL 연결을 확인한다.

```sql
SELECT 1 AS test;
```

기대 결과: `{ test: 1 }` 반환

**Step 4: 커밋 (해당 없음 — 인프라 작업)**

---

## Task 1: DB 테이블 생성

**목표:** `context_events` 테이블을 PostgreSQL에 생성한다.

**Step 1: 테이블 생성 SQL 실행**

n8n의 PostgreSQL 노드 (Execute 모드)로 아래 SQL을 실행한다:

```sql
CREATE TABLE IF NOT EXISTS context_events (
    id SERIAL PRIMARY KEY,
    source VARCHAR(20) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(100) NOT NULL,
    title TEXT,
    status VARCHAR(50),
    metadata JSONB,
    actor VARCHAR(100),
    project VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(source, entity_id)
);

CREATE INDEX IF NOT EXISTS idx_context_events_source ON context_events(source);
CREATE INDEX IF NOT EXISTS idx_context_events_updated ON context_events(updated_at);
CREATE INDEX IF NOT EXISTS idx_context_events_actor ON context_events(actor);
```

**Step 2: 테이블 확인**

```sql
SELECT column_name, data_type FROM information_schema.columns
WHERE table_name = 'context_events' ORDER BY ordinal_position;
```

기대 결과: 10개 컬럼 목록 반환

**Step 3: 커밋 (해당 없음 — DB 작업)**

---

## Task 2: WF1 — Linear 이벤트 수집 워크플로우

**목표:** Linear 웹훅 이벤트를 받아 `context_events` 테이블에 저장하는 워크플로우를 만든다.

**노드 흐름:**
```
[Webhook Trigger] → [Code: 이벤트 파싱] → [PostgreSQL: UPSERT]
```

**Step 1: 워크플로우 생성**

n8n MCP 도구로 `Linear 맥락 수집` 워크플로우를 생성한다.

**Step 2: Webhook 트리거 노드 추가**

- 노드 타입: `n8n-nodes-base.webhook`
- HTTP Method: POST
- Path: `linear-context-webhook`
- Authentication: None (Linear 웹훅은 HMAC 시그니처로 검증, 추후 Code 노드에서 처리 가능)

**Step 3: Code 노드 추가 — 이벤트 파싱**

- 노드 타입: `n8n-nodes-base.code`
- 노드 이름: `parse_linear_event` (한국어 이름 금지 — `n8n-gotchas` 참조)

```javascript
const body = $input.first().json.body || $input.first().json;

// Linear 웹훅 페이로드 구조
const action = body.action; // 'create', 'update', 'remove'
const type = body.type;     // 'Issue', 'Comment', 'Project', 'Cycle'
const data = body.data;

// Issue 이벤트만 처리 (MVP)
if (type !== 'Issue') {
  return []; // 빈 배열 반환으로 다음 노드 스킵
}

const eventType = `issue_${action}`;
const entityId = data.id;
const title = data.title || '';
const status = data.state?.name || data.status || '';
const actor = data.assignee?.name || data.creator?.name || '';
const project = data.project?.name || data.team?.name || '';

const metadata = {
  priority: data.priority,
  labels: data.labels?.map(l => l.name) || [],
  url: data.url || '',
  description: data.description || '',
  updatedFields: body.updatedFrom || {},
  number: data.number,
  identifier: data.identifier
};

return [{
  json: {
    source: 'linear',
    event_type: eventType,
    entity_id: entityId,
    title,
    status,
    metadata: JSON.stringify(metadata),
    actor,
    project
  }
}];
```

**Step 4: PostgreSQL 노드 추가 — UPSERT**

- 노드 타입: `n8n-nodes-base.postgres`
- Operation: Execute Query
- Credential: Task 0에서 생성한 PostgreSQL credential

```sql
INSERT INTO context_events (source, event_type, entity_id, title, status, metadata, actor, project)
VALUES ($1, $2, $3, $4, $5, $6::jsonb, $7, $8)
ON CONFLICT (source, entity_id)
DO UPDATE SET
  event_type = EXCLUDED.event_type,
  title = EXCLUDED.title,
  status = EXCLUDED.status,
  metadata = EXCLUDED.metadata,
  actor = EXCLUDED.actor,
  project = EXCLUDED.project,
  updated_at = NOW();
```

Query Parameters (순서대로):
1. `{{ $json.source }}`
2. `{{ $json.event_type }}`
3. `{{ $json.entity_id }}`
4. `{{ $json.title }}`
5. `{{ $json.status }}`
6. `{{ $json.metadata }}`
7. `{{ $json.actor }}`
8. `{{ $json.project }}`

**Step 5: 노드 연결**

Webhook → parse_linear_event → PostgreSQL 순서로 연결한다.

**Step 6: 워크플로우 활성화**

워크플로우를 활성화하고 웹훅 URL을 확인한다. URL 형식:
`https://<n8n-domain>/webhook/linear-context-webhook`

**Step 7: Linear 웹훅 등록**

Linear Settings → API → Webhooks에서:
- URL: 위에서 확인한 웹훅 URL
- Resource types: Issues (최소 MVP)
- Label: `context-collector`

**Step 8: 수동 테스트**

Linear에서 이슈를 하나 생성/수정한 뒤, PostgreSQL에서 확인:

```sql
SELECT * FROM context_events WHERE source = 'linear' ORDER BY updated_at DESC LIMIT 5;
```

기대 결과: 방금 변경한 이슈의 데이터가 저장되어 있음

**Step 9: 커밋**

```bash
git add docs/plans/
git commit -m "feat: Linear 맥락 수집 워크플로우 구축 완료"
```

---

## Task 3: WF2 — GitHub 이벤트 수집 워크플로우

**목표:** GitHub 웹훅 이벤트를 받아 `context_events` 테이블에 저장하는 워크플로우를 만든다.

**노드 흐름:**
```
[Webhook Trigger] → [Code: 이벤트 파싱] → [PostgreSQL: UPSERT]
```

**Step 1: 워크플로우 생성**

n8n MCP 도구로 `GitHub 맥락 수집` 워크플로우를 생성한다.

**Step 2: Webhook 트리거 노드 추가**

- 노드 타입: `n8n-nodes-base.webhook`
- HTTP Method: POST
- Path: `github-context-webhook`

**Step 3: Code 노드 추가 — 이벤트 파싱**

- 노드 이름: `parse_github_event`

```javascript
const headers = $input.first().json.headers || {};
const body = $input.first().json.body || $input.first().json;

const githubEvent = headers['x-github-event'] || body['x-github-event'] || 'unknown';

let events = [];

if (githubEvent === 'pull_request') {
  const pr = body.pull_request;
  const action = body.action; // opened, closed, synchronize, reopened, review_requested
  events.push({
    source: 'github',
    event_type: `pr_${action}`,
    entity_id: `pr-${pr.number}-${body.repository.full_name}`,
    title: pr.title,
    status: pr.merged ? 'merged' : pr.state, // open, closed, merged
    metadata: JSON.stringify({
      number: pr.number,
      branch: pr.head.ref,
      base: pr.base.ref,
      url: pr.html_url,
      additions: pr.additions,
      deletions: pr.deletions,
      changed_files: pr.changed_files,
      reviewers: (pr.requested_reviewers || []).map(r => r.login),
      draft: pr.draft
    }),
    actor: pr.user.login,
    project: body.repository.full_name
  });
} else if (githubEvent === 'push') {
  const commits = body.commits || [];
  // Push 이벤트는 entity_id를 branch 단위로 관리 (최신 push로 업데이트)
  const branch = (body.ref || '').replace('refs/heads/', '');
  events.push({
    source: 'github',
    event_type: 'push',
    entity_id: `push-${branch}-${body.repository.full_name}`,
    title: `${commits.length}개 커밋 → ${branch}`,
    status: 'pushed',
    metadata: JSON.stringify({
      branch,
      commits: commits.slice(0, 10).map(c => ({
        message: c.message,
        author: c.author.name,
        timestamp: c.timestamp
      })),
      total_commits: commits.length,
      url: body.compare
    }),
    actor: body.pusher?.name || body.sender?.login || '',
    project: body.repository.full_name
  });
} else if (githubEvent === 'pull_request_review') {
  const review = body.review;
  const pr = body.pull_request;
  events.push({
    source: 'github',
    event_type: `review_${body.action}`,
    entity_id: `review-${review.id}`,
    title: `PR #${pr.number} 리뷰: ${review.state}`,
    status: review.state, // approved, changes_requested, commented
    metadata: JSON.stringify({
      pr_number: pr.number,
      pr_title: pr.title,
      body: review.body || '',
      url: review.html_url
    }),
    actor: review.user.login,
    project: body.repository.full_name
  });
}

if (events.length === 0) {
  return []; // 지원하지 않는 이벤트는 스킵
}

return events.map(e => ({ json: e }));
```

**Step 4: PostgreSQL 노드 추가 — UPSERT**

Task 2의 Step 4와 동일한 SQL과 파라미터 구성.

**Step 5: 노드 연결**

Webhook → parse_github_event → PostgreSQL 순서로 연결한다.

**Step 6: 워크플로우 활성화**

웹훅 URL 확인: `https://<n8n-domain>/webhook/github-context-webhook`

**Step 7: GitHub 웹훅 등록**

GitHub 레포 Settings → Webhooks → Add webhook:
- Payload URL: 위에서 확인한 웹훅 URL
- Content type: `application/json`
- Events: "Let me select individual events" → Pull requests, Pushes, Pull request reviews 선택

하나의 웹훅으로 여러 레포를 다루려면 Organization 웹훅 사용, 또는 레포마다 각각 등록.

**Step 8: 수동 테스트**

GitHub에서 PR을 생성하거나 커밋을 push한 뒤 확인:

```sql
SELECT * FROM context_events WHERE source = 'github' ORDER BY updated_at DESC LIMIT 5;
```

기대 결과: 방금 수행한 GitHub 활동이 저장되어 있음

**Step 9: 커밋**

```bash
git add docs/plans/
git commit -m "feat: GitHub 맥락 수집 워크플로우 구축 완료"
```

---

## Task 4: WF3 — 맥락 조회 워크플로우 (MCP 인터페이스)

**목표:** PostgreSQL에 저장된 맥락을 MCP 도구로 조회하여 Markdown 요약을 반환하는 워크플로우를 만든다.

**참고:** 이 워크플로우는 n8n MCP 서버를 통해 Claude Code에서 도구로 호출된다. n8n MCP 서버의 도구 노출 방식에 따라 구현이 달라질 수 있다. Webhook 기반 또는 n8n MCP 내장 도구 방식 중 가능한 방식으로 구현한다.

**노드 흐름:**
```
[Webhook/MCP Trigger] → [Code: 파라미터 파싱] → [PostgreSQL: 쿼리] → [Code: Markdown 포맷팅] → [Respond to Webhook]
```

**Step 1: 워크플로우 생성**

n8n MCP 도구로 `맥락 조회 API` 워크플로우를 생성한다.

**Step 2: Webhook 트리거 노드 추가**

- 노드 타입: `n8n-nodes-base.webhook`
- HTTP Method: GET
- Path: `get-my-context`
- Response Mode: `lastNode` (마지막 노드의 출력을 응답으로 반환)

**Step 3: Code 노드 — 파라미터 파싱**

- 노드 이름: `parse_query_params`

```javascript
const query = $input.first().json.query || {};

const source = query.source || null;       // 'linear' | 'github' | null (전체)
const days = parseInt(query.days) || 14;   // 기본 14일
const status = query.status || null;       // 특정 상태 필터
const project = query.project || null;     // 특정 프로젝트 필터

// WHERE 절 동적 생성
let conditions = [`updated_at >= NOW() - INTERVAL '${days} days'`];
let params = [];
let paramIndex = 1;

if (source) {
  conditions.push(`source = $${paramIndex}`);
  params.push(source);
  paramIndex++;
}
if (status) {
  conditions.push(`status = $${paramIndex}`);
  params.push(status);
  paramIndex++;
}
if (project) {
  conditions.push(`project = $${paramIndex}`);
  params.push(project);
  paramIndex++;
}

const whereClause = conditions.join(' AND ');
const sql = `SELECT * FROM context_events WHERE ${whereClause} ORDER BY updated_at DESC LIMIT 100`;

return [{
  json: { sql, params, days, source }
}];
```

**Step 4: PostgreSQL 노드 — 쿼리 실행**

- Operation: Execute Query
- Query: `{{ $json.sql }}`
- Query Parameters: `{{ $json.params }}`

**주의:** 동적 SQL을 쓰되, 파라미터화된 값은 항상 Query Parameters로 전달하여 SQL injection을 방지한다. `days`는 정수로 파싱 후 문자열에 직접 포함하므로 안전하다.

**Step 5: Code 노드 — Markdown 포맷팅**

- 노드 이름: `format_markdown`

```javascript
const items = $input.all().map(item => item.json);
const queryInfo = $('parse_query_params').first().json;
const days = queryInfo.days;
const today = new Date().toISOString().split('T')[0];

if (items.length === 0) {
  return [{
    json: {
      response: `## 현재 맥락 (${today} 기준, 최근 ${days}일)\n\n수집된 맥락이 없습니다.`
    }
  }];
}

// 소스별 분류
const linear = items.filter(i => i.source === 'linear');
const github = items.filter(i => i.source === 'github');

let md = `## 현재 맥락 (${today} 기준, 최근 ${days}일)\n\n`;

// Linear 섹션
if (linear.length > 0) {
  const byStatus = {};
  linear.forEach(i => {
    const s = i.status || '상태 없음';
    if (!byStatus[s]) byStatus[s] = [];
    byStatus[s].push(i);
  });

  md += `### Linear 이슈 (${linear.length}건)\n\n`;
  for (const [status, issues] of Object.entries(byStatus)) {
    md += `**${status}** (${issues.length}건)\n`;
    issues.forEach(i => {
      const meta = typeof i.metadata === 'string' ? JSON.parse(i.metadata) : (i.metadata || {});
      const identifier = meta.identifier || '';
      const priority = meta.priority ? ` P${meta.priority}` : '';
      md += `- [${identifier}] ${i.title}${priority} (${i.project || ''})\n`;
    });
    md += '\n';
  }
}

// GitHub 섹션
if (github.length > 0) {
  const prs = github.filter(i => i.event_type.startsWith('pr_'));
  const pushes = github.filter(i => i.event_type === 'push');
  const reviews = github.filter(i => i.event_type.startsWith('review_'));

  md += `### GitHub 활동 (${github.length}건)\n\n`;

  if (prs.length > 0) {
    md += `**Pull Requests** (${prs.length}건)\n`;
    prs.forEach(i => {
      const meta = typeof i.metadata === 'string' ? JSON.parse(i.metadata) : (i.metadata || {});
      const draft = meta.draft ? ' [Draft]' : '';
      md += `- PR #${meta.number || ''}${draft} ${i.title} (${i.status}, ${i.project})\n`;
    });
    md += '\n';
  }

  if (pushes.length > 0) {
    md += `**Push 활동** (${pushes.length}건)\n`;
    pushes.forEach(i => {
      const meta = typeof i.metadata === 'string' ? JSON.parse(i.metadata) : (i.metadata || {});
      md += `- ${i.title} (${i.project})\n`;
    });
    md += '\n';
  }

  if (reviews.length > 0) {
    md += `**코드 리뷰** (${reviews.length}건)\n`;
    reviews.forEach(i => {
      md += `- ${i.title} by ${i.actor} (${i.project})\n`;
    });
    md += '\n';
  }
}

return [{
  json: { response: md }
}];
```

**Step 6: Respond to Webhook 노드 추가**

- 노드 타입: `n8n-nodes-base.respondToWebhook`
- Respond With: JSON
- Response Body: `{{ $json.response }}`

또는 Webhook 노드의 Response Mode가 `lastNode`이면 이 노드 없이도 마지막 Code 노드의 출력이 자동 반환된다.

**Step 7: 노드 연결**

Webhook → parse_query_params → PostgreSQL → format_markdown → Respond to Webhook

**Step 8: 워크플로우 활성화**

웹훅 URL 확인: `https://<n8n-domain>/webhook/get-my-context`

**Step 9: 수동 테스트**

브라우저 또는 curl로 테스트:

```bash
curl "https://<n8n-domain>/webhook/get-my-context?days=14"
```

기대 결과: Task 2, 3에서 저장된 맥락이 Markdown 형식으로 반환

**Step 10: MCP 연동 확인**

Claude Code 세션에서 이 엔드포인트를 MCP 도구로 호출할 수 있는지 확인한다. 현재 n8n MCP 서버(`n8n-mcp.unuuuuu.com`)가 이 워크플로우의 웹훅을 도구로 노출하는 방법을 확인해야 한다.

옵션 A: `.mcp.json`에 별도 MCP 서버로 등록
옵션 B: 기존 n8n MCP 서버가 자동으로 웹훅 워크플로우를 도구로 노출

어떤 방식이든, 최종적으로 Claude Code에서 `get_my_context` 도구를 호출하면 Markdown 요약이 반환되어야 한다.

**Step 11: 커밋**

```bash
git add docs/plans/
git commit -m "feat: 맥락 조회 MCP 워크플로우 구축 완료"
```

---

## Task 5: 통합 검증

**목표:** 3개 워크플로우가 올바르게 작동하는지 end-to-end로 검증한다.

**Step 1: Linear 이벤트 흐름 검증**

1. Linear에서 이슈 생성
2. PostgreSQL에서 해당 이슈 데이터 확인
3. 조회 API에서 해당 이슈가 Markdown에 포함되는지 확인

**Step 2: GitHub 이벤트 흐름 검증**

1. GitHub에서 PR 생성 또는 커밋 push
2. PostgreSQL에서 해당 데이터 확인
3. 조회 API에서 해당 활동이 Markdown에 포함되는지 확인

**Step 3: Claude Code 세션에서 조회 테스트**

Claude Code 세션에서 MCP 도구로 맥락을 조회하여 정상 반환되는지 확인.

**Step 4: 최종 커밋**

```bash
git add -A
git commit -m "feat: Linear/GitHub 맥락 수집 시스템 구축 완료"
```
