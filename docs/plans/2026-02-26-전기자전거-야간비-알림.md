# 전기자전거 야간 비 알림 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 아침에 전기자전거 출근 여부를 텔레그램으로 확인하고, 전기자전거를 탄 날 저녁 9시에 야간~새벽~다음날 아침 비 예보를 텔레그램으로 알려주는 n8n 워크플로우 시스템 구축

**Architecture:** 2개의 n8n 워크플로우로 구성한다. Workflow 1(아침 질문)은 스케줄 트리거로 평일 아침 텔레그램 인라인 키보드를 보낸다. Workflow 2(콜백+알림)는 텔레그램 콜백을 받아 전기자전거 선택 시 Wait 노드로 저녁 9시까지 대기한 후 Open-Meteo API로 야간 강수 예보를 조회하여 비가 예상되면 알림을 보낸다. Wait 노드를 활용해 워크플로우 간 상태 공유 없이 단일 실행 흐름으로 처리한다.

**Tech Stack:** n8n, Telegram Bot API (인라인 키보드 + 콜백), Open-Meteo API (무료, API 키 불필요)

---

## 전체 흐름

```
[Workflow 1: 아침 질문]
Schedule Trigger (평일 8:00 AM KST)
  → Telegram: "오늘 뭐 타고 출근했어?" + 인라인 키보드

[Workflow 2: 콜백 → 대기 → 날씨 확인 → 알림]
Telegram Trigger (callback_query)
  → IF: callback_data == "ebike"?
    → True:
      → Telegram: Answer "전기자전거 확인! 저녁에 날씨 알려줄게요"
      → Wait (오늘 21:00까지 대기)
      → HTTP Request (Open-Meteo API: 21시~익일 09시 강수 예보)
      → Code (강수 데이터 파싱, 비 여부 판단)
      → IF: 비 예보?
        → True: Telegram "비 예보! 자전거 조치 필요"
        → False: Telegram "비 안 와요, 걱정 마세요"
    → False:
      → Telegram: Answer "확인!"
```

---

## 사전 확인 사항

플랜 실행 전에 다음이 준비되어 있어야 한다:

- [ ] Telegram 봇 토큰 (BotFather에서 생성)
- [ ] n8n에 Telegram API 자격증명(Credential) 등록 완료
- [ ] 사용자 Telegram Chat ID 확인 (`https://api.telegram.org/bot<TOKEN>/getUpdates`)
- [ ] 자전거 보관 위치의 위도/경도 좌표 (Open-Meteo API 파라미터용)

---

### Task 1: Workflow 1 — 아침 출근 수단 질문

평일 아침에 텔레그램 인라인 키보드로 출근 수단을 묻는 워크플로우.

**Step 1: 워크플로우 생성**

`n8n_create_workflow` 도구로 아래 워크플로우를 생성한다:

```json
{
  "name": "전기자전거 출근 확인",
  "nodes": [
    {
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [250, 300],
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * 1-5"
            }
          ]
        }
      }
    },
    {
      "name": "출근 수단 질문",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [480, 300],
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{$vars.TELEGRAM_CHAT_ID}}",
        "text": "오늘 뭐 타고 출근했어?",
        "replyMarkup": "inlineKeyboard",
        "inlineKeyboard": {
          "rows": [
            {
              "row": [
                { "text": "전기자전거 🚲", "callbackData": "ebike" },
                { "text": "기타 🚶", "callbackData": "other" }
              ]
            }
          ]
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram API"
        }
      }
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [{ "node": "출근 수단 질문", "type": "main", "index": 0 }]
      ]
    }
  }
}
```

> **참고:** `TELEGRAM_CHAT_ID`는 n8n Variables에 등록하거나, 직접 숫자로 대체한다. `TELEGRAM_CREDENTIAL_ID`는 n8n에 등록된 자격증명의 실제 ID로 교체한다.

**Step 2: 워크플로우 검증**

`n8n_validate_workflow`로 검증한다. 에러가 있으면 수정 후 재검증.

**Step 3: 수동 테스트**

`n8n_test_workflow`로 실행하여 텔레그램에 인라인 키보드 메시지가 도착하는지 확인한다.

---

### Task 2: Workflow 2 — 콜백 처리 + 저녁 날씨 알림

텔레그램 콜백을 받아, 전기자전거 선택 시 저녁 9시에 날씨를 확인하여 알림을 보내는 워크플로우.

**Step 1: 워크플로우 생성**

`n8n_create_workflow` 도구로 아래 워크플로우를 생성한다:

```json
{
  "name": "전기자전거 날씨 알림",
  "nodes": [
    {
      "name": "Telegram Trigger",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.1,
      "position": [250, 300],
      "parameters": {
        "updates": ["callback_query"]
      },
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram API"
        }
      }
    },
    {
      "name": "전기자전거인가?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [480, 300],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true },
          "conditions": [
            {
              "leftValue": "={{ $json.callback_query.data }}",
              "rightValue": "ebike",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      }
    },
    {
      "name": "자전거 확인 응답",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [720, 200],
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{ $json.callback_query.message.chat.id }}",
        "text": "🚲 전기자전거 확인! 오늘 저녁 9시에 날씨 알려줄게요."
      },
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram API"
        }
      }
    },
    {
      "name": "기타 확인 응답",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [720, 450],
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{ $json.callback_query.message.chat.id }}",
        "text": "확인!"
      },
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram API"
        }
      }
    },
    {
      "name": "저녁 9시까지 대기",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [960, 200],
      "parameters": {
        "resume": "timeInterval",
        "amount": "={{(() => { const now = new Date(); const target = new Date(); target.setHours(21, 0, 0, 0); if (target <= now) return 0; return Math.ceil((target - now) / 60000); })()}}",
        "unit": "minutes"
      }
    },
    {
      "name": "날씨 조회",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1200, 200],
      "parameters": {
        "method": "GET",
        "url": "https://api.open-meteo.com/v1/forecast",
        "authentication": "none",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            { "name": "latitude", "value": "={{$vars.LOCATION_LAT}}" },
            { "name": "longitude", "value": "={{$vars.LOCATION_LON}}" },
            { "name": "hourly", "value": "precipitation_probability,precipitation,weather_code" },
            { "name": "timezone", "value": "Asia/Seoul" },
            { "name": "forecast_days", "value": "2" }
          ]
        }
      }
    },
    {
      "name": "강수 데이터 파싱",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 200],
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst hourly = data.hourly;\nconst times = hourly.time;\nconst precProb = hourly.precipitation_probability;\nconst precAmount = hourly.precipitation;\nconst weatherCode = hourly.weather_code;\n\n// 오늘 21시 ~ 내일 09시 (12시간) 필터링\nconst now = new Date();\nconst todayStr = now.toISOString().split('T')[0];\nconst tomorrowStr = new Date(now.getTime() + 86400000).toISOString().split('T')[0];\n\nconst startHour = `${todayStr}T21:00`;\nconst endHour = `${tomorrowStr}T09:00`;\n\nlet rainHours = [];\nlet maxProb = 0;\nlet totalPrecipitation = 0;\n\nfor (let i = 0; i < times.length; i++) {\n  if (times[i] >= startHour && times[i] <= endHour) {\n    if (precProb[i] > maxProb) maxProb = precProb[i];\n    totalPrecipitation += precAmount[i];\n    if (precProb[i] >= 30 || precAmount[i] > 0) {\n      const hour = times[i].split('T')[1];\n      rainHours.push(`${hour} (${precProb[i]}%, ${precAmount[i]}mm)`);\n    }\n  }\n}\n\nconst willRain = maxProb >= 30 || totalPrecipitation > 0;\n\nlet message = '';\nif (willRain) {\n  message = `🌧️ 비 예보가 있어요! 전기자전거 조치가 필요합니다.\\n\\n`;\n  message += `최대 강수확률: ${maxProb}%\\n`;\n  message += `예상 총 강수량: ${totalPrecipitation.toFixed(1)}mm\\n\\n`;\n  message += `시간대별:\\n${rainHours.join('\\n')}`;\n} else {\n  message = `☀️ 오늘 밤~내일 아침 비 소식 없어요. 안심하세요!`;\n}\n\nreturn [{ json: { willRain, maxProb, totalPrecipitation, rainHours, message } }];"
      }
    },
    {
      "name": "비 오나?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1680, 200],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true },
          "conditions": [
            {
              "leftValue": "={{ $json.willRain }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      }
    },
    {
      "name": "비 알림",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1920, 100],
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{$vars.TELEGRAM_CHAT_ID}}",
        "text": "={{ $json.message }}"
      },
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram API"
        }
      }
    },
    {
      "name": "비 안옴 알림",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1920, 350],
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{$vars.TELEGRAM_CHAT_ID}}",
        "text": "={{ $json.message }}"
      },
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_CREDENTIAL_ID",
          "name": "Telegram API"
        }
      }
    }
  ],
  "connections": {
    "Telegram Trigger": {
      "main": [
        [{ "node": "전기자전거인가?", "type": "main", "index": 0 }]
      ]
    },
    "전기자전거인가?": {
      "main": [
        [{ "node": "자전거 확인 응답", "type": "main", "index": 0 }],
        [{ "node": "기타 확인 응답", "type": "main", "index": 0 }]
      ]
    },
    "자전거 확인 응답": {
      "main": [
        [{ "node": "저녁 9시까지 대기", "type": "main", "index": 0 }]
      ]
    },
    "저녁 9시까지 대기": {
      "main": [
        [{ "node": "날씨 조회", "type": "main", "index": 0 }]
      ]
    },
    "날씨 조회": {
      "main": [
        [{ "node": "강수 데이터 파싱", "type": "main", "index": 0 }]
      ]
    },
    "강수 데이터 파싱": {
      "main": [
        [{ "node": "비 오나?", "type": "main", "index": 0 }]
      ]
    },
    "비 오나?": {
      "main": [
        [{ "node": "비 알림", "type": "main", "index": 0 }],
        [{ "node": "비 안옴 알림", "type": "main", "index": 0 }]
      ]
    }
  }
}
```

> **교체 필요:** `TELEGRAM_CREDENTIAL_ID`를 실제 자격증명 ID로, `LOCATION_LAT`/`LOCATION_LON`을 n8n Variables에 등록하거나 직접 좌표로 대체한다.

**Step 2: 워크플로우 검증**

`n8n_validate_workflow`로 검증한다. 특히 다음을 확인:
- Telegram Trigger의 `updates` 파라미터가 `callback_query`를 포함하는지
- Wait 노드의 시간 계산 표현식이 유효한지
- HTTP Request의 Open-Meteo URL과 쿼리 파라미터가 올바른지
- Code 노드의 JavaScript 문법 에러가 없는지

**Step 3: 수동 테스트**

1. Workflow 1을 수동 실행하여 텔레그램에 인라인 키보드 도착 확인
2. "전기자전거 🚲" 버튼 클릭
3. Workflow 2가 콜백을 받아 "전기자전거 확인!" 응답을 보내는지 확인
4. Wait 노드를 테스트용으로 짧은 시간(1분)으로 임시 변경하여 날씨 조회~알림 흐름 확인
5. 테스트 후 Wait 노드를 원래 설정(21:00)으로 복원

---

### Task 3: 통합 테스트 + 활성화

**Step 1: 양쪽 워크플로우 활성화**

`n8n_activate_workflow`로 두 워크플로우를 모두 활성화한다.

**Step 2: E2E 테스트**

1. Workflow 1을 수동 트리거하여 텔레그램에 메시지 도착 확인
2. "전기자전거 🚲" 클릭 → 확인 응답 수신 확인
3. Wait 노드가 대기 상태에 들어갔는지 n8n UI의 Executions에서 확인
4. (선택) Wait 시간을 단축하여 날씨 알림까지 전체 흐름 검증

**Step 3: 기록 업데이트**

`docs/lookups/2026-02-26-전기자전거-야간비-알림.md`의 다음 단계에 실제 워크플로우 ID와 배포 상태를 추가한다.

**Step 4: 커밋**

```bash
git add docs/lookups/2026-02-26-전기자전거-야간비-알림.md
git commit -m "docs: 전기자전거 야간 비 알림 워크플로우 배포 기록 업데이트"
```

---

## 설계 결정 근거

### Wait 노드 vs 크로스 워크플로우 상태 관리

**선택: Wait 노드**

콜백을 받은 실행이 그대로 저녁 9시까지 대기하므로 워크플로우 간 상태 공유가 불필요하다. n8n의 staticData나 외부 저장소 없이 단일 실행 흐름으로 해결된다.

**트레이드오프:** n8n 서버가 Wait 중에 재시작되면 실행이 유실될 수 있다. 하지만 날씨 알림 누락은 치명적이지 않으므로 이 단순함이 더 가치 있다.

### Open-Meteo API

- 무료, API 키 불필요
- 시간별 강수확률(`precipitation_probability`)과 강수량(`precipitation`) 제공
- `timezone=Asia/Seoul` 파라미터로 KST 기준 데이터 반환
- 기상청 API 대비 설정이 단순하고 안정적

### 강수 판단 기준

- 강수확률 30% 이상 OR 강수량 > 0mm인 시간대가 하나라도 있으면 "비 예보"로 판단
- 21:00~09:00 (12시간) 구간만 확인 — 자전거가 야외에 노출되는 시간대
